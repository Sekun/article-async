# Exemple n°5 : Les entrées/sorties, le nerf de la guerre

Vous vous demandez peut-être pourquoi on parle tout le temps d'*IO* en
programmation asynchrone. En effet, les entrées/sorties des programmes
semblent indissociables du concept d'asynchrone, à tel point que cela se
traduit jusque dans le nom de la bibliothèque standard `asyncio` de Python.
Mais *pourquoi* ?

Commençons par une définition : une *IO*, c'est une opération pendant laquelle
un programme *interagit avec un flux de données*. Ce **flux de données** peut
être plein de choses : une connexion réseau, les flux standard `STDIN`,
`STDOUT` ou `STDERR` du processus en cours d'exécution, un fichier, ou même
une abstraction matérielle[^abstraction]. « Interagir avec un flux de
données », ça veut dire l'**ouvrir**, **lire** ou **écrire** dedans ou le
**fermer**.

[^abstraction]: On peut par exemple lire un son sous Linux en *écrivant*
des données dans un fichier spécial qui représente la carte son !

Jusqu'ici, nous avons travaillé sur des exemples très simples qui se
contentaient d'afficher des choses à l'écran pour bien comprendre l'ordre dans
lequel les instructions étaient exécutées. Nos tâches ne réalisaient du coup
que des entrées/sorties, certes, mais celles-ci étaient *synchrones* : on a
considéré jusqu'à maintenant qu'un `print()` dans la console s'exécute
immédiatement et sans délai lors de son appel, ce qui est parfaitement
intuitif...

... mais pas toujours le reflet de la réalité.

Prenons par exemple une IO très simple que vous réalisez en permanence
sur votre ordinateur ou smartphone sans même vous en rendre compte : **que se
passe-t-il entre le moment où vous avez cliqué sur un lien dans une page web,
et celui où le résultat commence à s'afficher sur votre écran** ?

Eh bien vous **attendez**. Tout simplement. Et votre navigateur aussi. Sans
rentrer dans le détail du protocole HTTP, on peut schématiser grossièrement ce
qui se passe comme ceci :


```
        Navigateur                           Serveur web
        ==========                           ===========

           [clic sur le lien]                     .
[création d'une requête HTTP]                     .
       [connexion au serveur]  ------>            .
            .                            [connexion reçue]
            .                  <------   [connexion acceptée]
        [envoi de la requête]  ------>            .
            .                            [réception de la requête]
            .                            [création de la réponse]
            .                  <------   [envoi de la réponse]
    [réception de la réponse]                     .
       [affichage de la page]
```

Dans ce schéma, tous les points (`.`) symbolisent une  attente. Un échange HTTP
(et plus généralement une IO), c'est une opération pendant laquelle les
programmes, passent le plus clair de leur temps à **ne rien faire**. Et votre
navigateur lui-même vous le dit (généralement dans un petit cadre en bas à
gauche de l'écran) :

![](src/img/waiting.png)

Dans ces conditions, l'idée de base de la programmation asynchrone est de
*mettre à profit* tout ce temps que l'on passe à attendre pendant la
réalisation d'une IO pour **s'occuper en faisant autre chose**.

L'exemple du serveur de *fast food* que nous avons modélisé plus tôt n'est pas
anodin ; qu'il s'agisse du serveur *bien réel* d'un restaurant ou celui d'une
application réseau, les deux réalisent en général des opérations comparables.
En effet, de très nombreux serveurs (par exemple d'applications Web)
fonctionnent plus ou moins suivant ce schéma :

1. Recevoir une requête, une commande ou un message,
2. Aller récupérer des ressources à différents endroits,
3. Combiner les ressources entre elles,
4. Répondre au client.

Dans ce schéma, les points 1, 2 et 4 peuvent être des *IO* :

1. Réception :
    * **Attente** d'une connexion,
    * Acceptation de la connexion,
    * **Attente** du message,
    * Réception du message
2. Récupérer des ressources :
    * S'il s'agit de ressources distantes :
        * Connexion à un service,
        * **Attente** de l'acceptation de la connexion,
        * Envoi d'une requête,
        * **Attente** que la réponse arrive,
        * Réception de la réponse,
    * Si la ressource est protégée par un verrou ou un sémaphore :
        * **Attente** de l'acquisition du verrou/sémaphore,
        * Récupération de la ressource,
        * Relâchement du verrou/sémaphore,
3. Combiner les ressources entre elles,
4. Répondre au client :
    * **Attente** que le *medium* soit disponible en écriture,
    * Envoi de la réponse.

Comme vous le voyez, il est vraiment *très* courant d'attendre pour un serveur.
Et il ne s'agit là que d'un schéma particulier dans une infinité d'applications
possibles.

Ainsi, il serait possible d'optimiser de nombreux programmes en les rendant
asynchrones, pour peu que l'on soit capable de rendre leurs *IO* **non
bloquantes**, c'est-à-dire que l'on puisse laisser la main à d'autres tâches au
lieu d'attendre, et reprendre celle-ci avec l'assurance que l'on pourra
réaliser une *IO* immédiatement.

